\section{Protocol}
\label{sec:protocol}

We describe a basic protocol first, for each of understanding, followed up by
extensions for reducing communication and an efficient protocol to handle
malicious publishers disrupting the computation. We present a simulator for the
basic protocol to prove that a real world adversary cannot do more harm then a
simulator can do in the ideal world (Definition~\ref{def:security}. We also
describe security of extensions. We describe our system in
Section~\ref{sec:system}, which is not a mere implementation of our protocol
with extensions; we use a range of system techniques to build a practical
system using our protocol as a foundation. 

We assume authenticated encrypted channels between publishers, subscribers with
\broker, \garbler. However, in our system, publishers and subscribers
communicate directly only with \broker and communicate indirectly with \garbler
through \broker. This is because we want to comply with MQTT protocol.

We describe our protocol. We describe system in Section~\ref{def:system}, and
we solve many issues that come into building a system.

We provide a simulator for our basic protocol, but after every extension we
describe security again.

\improvement{Malicious \broker doesn't affect privacy, online correctness}

\subsection{Basic Protocol}
\input{basic_protocol}

\subsection{Security Proof of Basic Protocol}
We describe a simulator \Sim that simulates the view of the \Adv in the real
world execution of our basic protocol of Figure~\ref{fig:basicprotocol}. Our
security definition~\ref{def:security} and simulator \Sim ensures both
confidentiality and correctness.

The interesting case is when a subset of publishers are malicious and are
colluding with honest-but-curious \broker. \garbler is non-colluding
honest-but-curious. A malicious subscriber only receives output; it can only
reveal its own output, which is also possible in the ideal world execution.\\[6pt]
\input{simulator}

\subsection{Reduced Communication Extension}
\input{extended_protocol}

\subsection{Efficient Wire Labels Consistency Check} In our basic
protocol, described in Figure~\ref{fig:basicprotocol}, we execute a new
instance of private set intersection \emph{cardinality} protocol for every
input bit of the circuit, which is expensive.  We present a more efficient wire
label consistency protocol:

For every input bit $b$ of circuit $C$, \garbler has both wire labels $w_0$ and
$w_1$, we call the set of these labels $W_\garbler$ and \broker has a wire
label $w_b$, we call the set of these labels $W_\broker$. Input consistency
check ensures that $w_b$ is either $w_0$ or $w_1$, otherwise the \broker would
be unable to evaluate the garbled circuit.

\input{input_consistency_protocol}


\paragraph{Garbled Circuit XOR Compatibility.}


* What if one publisher doesn't send wire labels. After timeout the broker can
inform the \garbler and it will use zero for such values in the circuit.

\improvement{We can hide $C$ using universal circuits.}
\unsure{Who forms the topics? Publishers, clients, or broker?}


\improvement{Using cut and choose for malicious security}

\unsure{What is our current model? Are publishers, subscribers malicious?}

\improvement{A publisher can always input wrong data, but there is nothing that
can be done for this? May be it could be detected if it is creating a real
problem.}

\improvement{A subscribing entity can setup it's own \garbler. First we explain
with \garbler as a separate tntity and then later explain how it can be
eliminated by transfering it's functionality to subscribers. Similary, we can
transfer some functionality to publishers. Which one of them is better?}
