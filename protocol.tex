\section{Protocol}
\label{sec:protocol}

\improvement{Maliciosu \broker doesn't affect privacy, online correctness}


\begin{figure*}[h]
\begin{mdframed}[style=myframe]

%\begin{itemize}[leftmargin=*, itemsep=6pt]

\initialize
\begin{itemize}[leftmargin=*]
 
	\item Each new publisher sends \broker a \policy specifying allowed
		computations on its data.

\end{itemize}

\subscribe
\begin{itemize}[leftmargin=*]

	\item To subscribe computation $C$, subscriber sends a subscription request
		containing $C$ to \broker. If \broker allows subscriber to learn $C$'s
		output, it adds the subscriber to a list of $C$'s subscribers. 

\end{itemize}

\publish
\begin{itemize}[leftmargin=*]
		
	\item To publish $k$th value, publisher generates two pseudorandom wire
		labels, $w_0$ and $w_1$, for each bit of the value. 
		
	\item For each input bit $b$, publisher sends only $w_b$ to \broker and sends
		both $w_0$ and $w_1$ to \garbler.

\end{itemize}

\process
\begin{itemize}[leftmargin=*]

	\item \broker waits for a specified time period $t$ to receive input wire
		labels, a single label $w_b$ for a bit $b$, from a subset of publishers
		$P_C$ whose policies allow $C$. After time period $t$, \broker sends
		\garbler identifiers of publishers in $P_C$ along with identifiers of
		publishers whose data wasn't received during time period $t$ and requests
		\garbler to garble circuit for $XOR \circ C$. $XOR$ is used to mask the
		output of the circuit.

	\item \broker sends \garbler the set of $C$'s subscribers $S_C$.
		
	\item \garbler generates a garbled circuit $GC$ for the circuit $XOR \circ C$
		using both wire labels for each input bit, $w_0$ and $w_1$ for a bit $b$,
		received from publishers in set $P_C$ hard-wiring nullifying value for
		publishers whose input labels weren't received by \broker as well as any
		publishers whose labels weren't received by \garbler. \garbler generates a
		random mask $r$ and use it to mask the output $o$ of $C$, such that
		evaluating $GC$ would result in a masked output $o+r$.
		
	\item \garbler sends $r$ to all subscribers in the set $S_C$ and $GC$ to
		\broker along with identifiers for publishers for which it hard-wired
		nullifying values.

	\item For every bit $b$ of the $C$ inputs, \garbler and \broker run a
		private set intersection \emph{cardinality} (PSI-C) protocol to determine
		wire labels consistency, i.e., if \broker input label for bit $b$, $w_b$,
		is one of the two \garbler labels for bit $b$, $w_0$ and $w_1$. If PSI-C
		outputs $1$, then the labels are consistent and if it's $0$ then the labels
		are inconsistent. \garbler will use nullifying values for all inconsistent
		wire labels. 
		
	\item \broker evaluates the garbled circuit using wire labels sent by
		publishers in set $P_C$ ignoring labels for which \garbler hard-wired
		nullifying values, obtains masked output $o \xor r$, and sends $o \xor r$
		to all subscribers of computation $C$.
  
	\item Subscribers in the set $S_C$ use mask $r$ to unmask the output $o$.

\end{itemize}

\end{mdframed}
\caption{Basic Protocol}
\label{fig:basicprotocol}
\end{figure*}


\being{itemize}[leftmargin=*]

	\item 

\end{itemize}



\begin{figure}[h]
\begin{mdframed}[style=myframe]

%\begin{itemize}[leftmargin=*, itemsep=6pt]

\initialize
\begin{itemize}[leftmargin=*]
 
	\item Each new publisher sends \broker a policy specifying allowed
		computations on its data and generates a truly random seed $s$ and send
		it to \garbler.

	\item All publishers and subscribers establish an authenticated encrypted
		channel with \broker and through \broker with \garbler.

\end{itemize}

\subscribe
\begin{itemize}[leftmargin=*]

	\item To subscribe computation $C$, subscriber sends a subscription request
	  containing $C$ to \broker and requests an output masking seed from
	  \garbler.

	\item \garbler sends a truly random seed $s'$ to the subscriber for
		computation $C$; generating a new seed if this is the first subscription
		for computation $C$.

\end{itemize}

\publish
\begin{itemize}[leftmargin=*]
		
	\item To publish $k$th value, publisher generates two pseudorandom wire
		labels, $w_0$ and $w_1$, using seed $s$, for each bit of the value.  $w_0$
		is $i$th and $w_1$ is $(i+1)$th numbers in pseudorandom sequence generated
		using seed $s$; $2kL \leq i < 2(k+1)L$, $L$ being the bit-length of a
		value.

	\item For each input bit $b$, publisher sends only wire label $w_b$ to
		\broker.

\end{itemize}

\process
\begin{itemize}[leftmargin=*]

	\item Once \broker has wire labels for all publishers' inputs required for
		computation $C$, it requests \garbler to garble a circuit for $C$.  
  
	\item \garbler independently generates input wire labels using seed $s$ from
		each publisher contributing input and an output mask $m$ using seed $s'$
		for each output bit.

	\item \garbler generates garbled circuit for $M \circ C(\cdot)$, composition
		of masking function $M:XOR$ and computation $C$, and sends it to \broker.

	\item \broker evaluates the garbled circuit using wire labels sent by
		publishers, obtains masked output $o \xor m$, and send $o \xor m$ to all
		subscribers of computation $C$.
  
	\item Subscribers generate the mask $m$ using the seed $s'$ and unmask the
		output $o$.

\end{itemize}

\end{mdframed}
\caption{Improved Protocol}
\label{fig:basicprotocol}
\end{figure}

\paragraph{Forward Security.}
\unsure{Do we have to generate seed and ratchet key? Can't we use the seed as a
ratchet key?}


\begin{itemize}[leftmargin=*]

		\item Generate a truly random key $K_0$.

		\item Generate, using KDF with key $K_0$, a pseudorandom seed $s_0$ and a
			pseudorandom key for the ratchet round $1$. Seed $s_0$ is used to
			generate pseudorandom strings during ratchet round $0$.

		\item At round $r$, using KDF with key $K_r$, generate a pseudorandom seed
			$s_r$ and key for ratchet round $r+1$. Seed $s_r$ is used to generate
			pseudorandom strings during ratchet round $r$.

\end{itemize}

\paragraph{Garbled Circuit XOR Compatibility.}


* What if one publisher doesn't send wire labels. After timeout the broker can
inform the \garbler and it will use zero for such values in the circuit.

\improvement{We can hide $C$ using universal circuits.}
\unsure{Who forms the topics? Publishers, clients, or broker?}


\improvement{Using cut and choose for malicious security}

\unsure{What is our current model? Are publishers, subscribers malicious?}

\improvement{A publisher can always input wrong data, but there is nothing that
can be done for this? May be it could be detected if it is creating a real
problem.}

\improvement{A subscribing entity can setup it's own \garbler. First we explain
with \garbler as a separate tntity and then later explain how it can be
eliminated by transfering it's functionality to subscribers. Similary, we can
transfer some functionality to publishers. Which one of them is better?}

\input{proof}
