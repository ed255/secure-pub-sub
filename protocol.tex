\section{Protocol}
\label{sec:protocol}

Here we describe our protocol simply; our system section explain the complete
implementation in detail.

* We minimize the communication with \garbler, using clever tricks, e.g.,
we don't need to send labels to \garbler for circuit garbling instead they
generate it independently using shared seed.

* publishers and subscribers only talk to the broker. The communication
between publishers and subscriber is done through \broker using end-to-end
encryption. This ensures that 

* Does the subscriber seed needs to be computation specific?

* We use ratcheting for forward security if seed is compromised.

* We assume PKI.

\paragraph{Intuition.}

\begin{figure}[h]
	\caption{Basic Protocol}
\label{fig:basicprotocol}
\begin{mdframed}[style=myframe]

%\begin{itemize}[leftmargin=*, itemsep=6pt]

\initialize
\begin{itemize}[leftmargin=*]
 
	\item Each new publisher sends \broker a policy specifying allowed
		computations on its data.
%		and generates a truly random seed $s$ and send
%		it to \garbler.

%	\item All publishers and subscribers establish an authenticated encrypted
%		channel with \broker and through \broker with \garbler.

\end{itemize}

\subscribe
\begin{itemize}[leftmargin=*]

	\item To subscribe computation $C$, subscriber sends a subscription request
		containing $C$ to \broker and requests an output mask $r$ for computation
		$C$ from \garbler.

	\item \garbler sends subscriber a pseudorandom mask $r$ for computation $C$;
		generating a new mask if this is the first subscription for computation
		$C$.

\end{itemize}

\publish
\begin{itemize}[leftmargin=*]
		
	\item To publish $k$th value, publisher generates two pseudorandom wire
		labels, $w_0$ and $w_1$, for each bit of the value. 
		
	\item For each input bit $b$, publisher sends only $w_b$ to \broker and sends
		both $w_0$ and $w_1$ to \garbler.

\end{itemize}

\compute
\begin{itemize}[leftmargin=*]

	\item Once \broker has wire labels for all publishers' inputs required for
		computation $C$, it requests \garbler to garble a circuit for $C$.  
  
	\item \garbler generates garbled circuit for $M \circ C$, composition of
		masking function $M:XOR$ and computation $C$ with a hardwired pseudorandom
		mask $r$ and sends garbled circuit to \broker.

	\item \broker evaluates the garbled circuit using wire labels sent by
		publishers, obtains masked output $o \xor r$, and sends $o \xor r$ to all
		subscribers of computation $C$.
  
	\item Subscribers use mask $r$ to unmask the output $o$.

\end{itemize}

\end{mdframed}
\end{figure}

\subsection{Basic Protocol}

\begin{figure}[h]
	\caption{Basic Protocol}
\label{fig:basicprotocol}
\begin{mdframed}[style=myframe]

%\begin{itemize}[leftmargin=*, itemsep=6pt]

\initialize
\begin{itemize}[leftmargin=*]
 
	\item Each new publisher sends \broker a policy specifying allowed
		computations on its data and generates a truly random seed $s$ and send
		it to \garbler.

	\item All publishers and subscribers establish an authenticated encrypted
		channel with \broker and through \broker with \garbler.

\end{itemize}

\subscribe
\begin{itemize}[leftmargin=*]

	\item To subscribe computation $C$, subscriber sends a subscription request
	  containing $C$ to \broker and requests an output masking seed from
	  \garbler.

	\item \garbler sends a truly random seed $s'$ to the subscriber for
		computation $C$; generating a new seed if this is the first subscription
		for computation $C$.

\end{itemize}

\publish
\begin{itemize}[leftmargin=*]
		
	\item To publish $k$th value, publisher generates two pseudorandom wire
		labels, $w_0$ and $w_1$, using seed $s$, for each bit of the value.  $w_0$
		is $i$th and $w_1$ is $(i+1)$th numbers in pseudorandom sequence generated
		using seed $s$; $2kL \leq i < 2(k+1)L$, $L$ being the bit-length of a
		value.

	\item For each input bit $b$, publisher sends only wire label $w_b$ to
		\broker.

\end{itemize}

\compute
\begin{itemize}[leftmargin=*]

	\item Once \broker has wire labels for all publishers' inputs required for
		computation $C$, it requests \garbler to garble a circuit for $C$.  
  
	\item \garbler independently generates input wire labels using seed $s$ from
		each publisher contributing input and an output mask $m$ using seed $s'$
		for each output bit.

	\item \garbler generates garbled circuit for $M \circ C(\cdot)$, composition
		of masking function $M:XOR$ and computation $C$, and sends it to \broker.

	\item \broker evaluates the garbled circuit using wire labels sent by
		publishers, obtains masked output $o \xor m$, and send $o \xor m$ to all
		subscribers of computation $C$.
  
	\item Subscribers generate the mask $m$ using the seed $s'$ and unmask the
		output $o$.

\end{itemize}

\end{mdframed}
\end{figure}

\paragraph{Forward Security.}
\unsure{Do we have to generate seed and ratchet key? Can't we use the seed as a
ratchet key?}


\begin{itemize}[leftmargin=*]

		\item Generate a truly random key $K_0$.

		\item Generate, using KDF with key $K_0$, a pseudorandom seed $s_0$ and a
			pseudorandom key for the ratchet round $1$. Seed $s_0$ is used to
			generate pseudorandom strings during ratchet round $0$.

		\item At round $r$, using KDF with key $K_r$, generate a pseudorandom seed
			$s_r$ and key for ratchet round $r+1$. Seed $s_r$ is used to generate
			pseudorandom strings during ratchet round $r$.

\end{itemize}

\paragraph{Garbled Circuit XOR Compatibility.}


* What if one publisher doesn't send wire labels. After timeout the broker can
inform the \garbler and it will use zero for such values in the circuit.

\subsection{Security Definition}

\paragraph{Ideal World.}
Our ideal functionality \F interacts with publishers, subscribers, \broker, and
\garbler as follows:

\begin{itemize}[leftmargin=*]
		\item Each publisher sends a \policy to \F and each subscriber sends a
			subscription message to \F containing subscribed computation $C$.
		
		\item All publishers whose data is required for $C$ upload data to \F. Let
			$\vec{x}$ be the vector containing all this data.

		\item \F sends $C$, \policy, and list of subscribers for $C$ to \broker.

		\item \F sends $C$ to \garbler.

		\item \garbler uploads to \F a pseudorandom mask $r$ for $C$.

		\item For each subscriber $S$ subscribed to computation $C$, \F awaits for
			\broker command allowing or denying $C(\vec{x})$; if \broker allows, \F
			sends $C(\vec{x}) \xor r$ and $r$ to $S$ and if \broker denies, \F sends
			empty message $\bot$.

\end{itemize}

\paragraph{Real World.} In real world, \F is replaced by our protocol~\ref{}.

\paragraph{Simulator.}

\Adv sends simulator inputs of malicious publishers and output masks for a
computations from malicious subscribers. \Sim uses zero inputs for honest
publishers and a random mask for all computations that malicious subscribers
are not subscribed to. \Sim sends all inputs and output mask to \F and learns
$\F(C, \vec(x))$. \Sim sends $\F(C, \vec(x))$ to $\Sim_{GC}$ and obtains a fake
garbled $GC_{fake}$. \Sim generates a single random wire label for each wire of
the circuit. \Sim sends $GC_{fake}$ and wire labels to \Adv. $\Sim_{GC}$ is
computationally indistinguishable from the garbled circuit generated in the
real execution, as garbled circuit distribution doesn't depend upon on the
input values. The pseudorandom wire labels are also computational
indistinguishable from actual wire labels.

This proof implies both privacy and correctness as distribution in both the
real and ideal world have a negligible difference. 


This proof holds even if we have \garbler colluding
with publishers and subscribers if \garbler generates output mask for each
computation $C$ independently and send it to subscribers.  



\Sim generates two random wire labels, $r_0$ and $r_1$ and send it to \Adv.
\Sim generates a random string of the same size as $o+r$ and send it to \Adv.

A malicious adversary can disrupt the computation by not providing publishers
input, using garbage value (simple sanity check), or use inconsistent labels.

In case, a publisehr input is absent, \Sim requests \F to use nullifying value,
e.g., $0$ for OR and $1$ for AND. For inconsistent wire labels.

\F will notice
and will generate it's own labels for the circuit and will use zero label to
garble the circuit. \Sim call \F to learn $C, C(\vec(x))$ and then invokes
$\Sim_{GC}$ with inputs $(C,C(\vec(x))$. $\Sim_{GC}$ will provide.


\paragraph{Correctness.}
As subscriber just receives the output, it cannot affect the output. The
publishers can disrupt the protocol by not providing input or using
inconsisstent wire labels. \broker and \garbler use a private set intersection
cardinality protocol to figure out if the labels are inconsistent. In case the
label are inconsistent, \garbler hard code a nullifying bit instead missing or
inconsistent wire labels.  

\Sim 


\Sim can call \F with output to get a garbled circuit.

For a bit $b$, publisher generates two wire labels $w_0$ and $w_1$, send both
$w_0$ and $w_1$ to \garbler and only $w_b$ to \broker.

Subscriber receives masked output $o+r$ from \broker and $r$ from \garbler.
Subscriber only recevies the output and hence cannot affect any part of the
protocol. It can only reveal it's own output.

A publisher sends two wire labels $w_0$ and $w_1$ to \garbler and 




Publishers security requirement is that 

The security requirement is that the adversary doesn't learn the uncompromsied
publishers data as well as processed data to which only uncompromised
subscribers are subscribed.

\paragraph{Simulator.}
We consider a computation $C$ that requires input from $p$ publishers and $s$
subscribers are subscribed for $C$. $m < p$ publishers are malicious and $n <
s$ subscribers are malicious. \Sim sends \Adv 


\Sim sends to \Adv output masks stored by all malicious subscribers


\Sim sends to \Adv output masks $r_0, \ldots, r_{m-1}$ for the union of all
computations for which compromised subscribers subscribed. \Sim 

output masks for compromised subscribers
outputs of compromised subscribers
inputs of compromised publishers
input wire labels for all publishers
GC



Consider a single comutation $C$ with p publishers and s subscribers, m
publishers are corrupt and n subscribetrs are corrupt. We need to generate a
view that simulates the view of honest publishers are subscribers.




GC, input wire labels, all labels for compromised parties, output seeds,
outputs.

\Sim sends to \Adv output masks $r_0,...,r_{m-1}$ for $m$ computations, which
is the union of all computations subscribed by compromised subscribers. \Sim
also sends random masks $r_m,...,r_{s-1}$ for the uncomprmoised subscribers.
\Sim also sends real wire labels for all compromised publishers and generate
fake labels for all uncompromised publishers. \Sim invokes $\Sim_GC$ with input
$(C, F(M \circ C, p_0, p_1, \ldots, p_N)$ and obtains a fake garbled circuit. 

If \garbler is compormised adversary can learn all the random masks, however,
it cannot send it to the \broker as we assume they won't collude. 

$r_0,...,r_{m-1}$ from computation $C$ of $m$
compromised subscribers

We show that the view of the adversary controlling $m$ malicious publishers,
$n$ malicious subscribers, and honest-but-curious \broker doesn't affect the
security of uncompromised publishers and subscribers.


\Adv sends a subscription request for computation $C$. \Sim sends the
pseudorandom mask $r'$ for $C$ to \Adv; generating fresh mask if this is the
first subscription for $C$.

\Sim generates a
pseudorandom mask $r'$ for $C$ and send it to \Adv. 

A malicious publisher can: \emph{a.} publish a garbage value, \emph{b.} doesn't
publish, \emph{c.} send inconsistent wire labels to \broker and \garbler, and
\emph{d.} send non-random wire labels to \broker and \garbler. A publisher can
always publish a garbage as it can choose any value for its input. This can be
avoided using redundant publishers. If a publisher whose input is needed for a
computation $C$, doesn't send it in timely manner; \broker can inform \garbler
of this and \garbler will send wire labels to nullify this publishers input,
e.g., zero labels for addition and one labels for multiplication. This reveals
to the \garbler the number of publishers who didn't publish their values. For
inconsistent labels, \broker and \garbler use private set intersection
cardinality to verify that \broker label is one of the two \garbler labels. Use
of non-random labels doesn't pose any security risk to good parties.

A malicious subscriber can only learn what it is subscribed for. A malicious
subscriber cannot do any harm beside leaking computations it is subscribed for.

If \garbler uses any labels other than what publishers sent; \broker will
detect it as it wouldn't be able to decrypt entire circuit. 

We can use cut-and-choose secure Yao's garbled circuits protocol to avoid
\garbler garbling a malicious circuit.

We can use MAC inside the circuit to handle malicious \broker.

or one labels

\unsure{Can this be avoided by implementing a limit on the max and min values?}

A
malicious publisher can only publish a garbage value either by 

not send anything

send inconsistent wire labels

send non-random labels: this doesn't reveal anything additional.


%In the real world, each publisher sends a \policy to
%\broker and each subscriber sends a subscription message containing computation
%$C$. For each input bit $b$, a publisher generates two wire labels, $w_0$ and
%$w_1$, sends $w_b$ to \broker, and sends both $w_0$ and $w_1$ to \garbler.
%
%Once \broker has input wire labels from all publishers whose input is required
%to compute $C$, it requests \garbler to garble a circuit for $M \circ C$, where
%$M$ is an XOR masking function. \garbler garbled circuit for $C(\cdot) \xor r$,
%with a pseudorandom mask $r$ hard wired in the circuit.
%

\improvement{We can hide $C$ using universal circuits.}
\unsure{Who forms the topics? Publishers, clients, or broker?}


\improvement{Using cut and choose for malicious security}

\unsure{What is our current model? Are publishers, subscribers malicious?}

\improvement{A publisher can always input wrong data, but there is nothing that
can be done for this? May be it could be detected if it is creating a real
problem.}

\improvement{A subscribing entity can setup it's own \garbler. First we explain
with \garbler as a separate tntity and then later explain how it can be
eliminated by transfering it's functionality to subscribers. Similary, we can
transfer some functionality to publishers. Which one of them is better?}

\input{proof}
