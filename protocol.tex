\section{Protocol}
\label{sec:protocol}

Here we describe our protocol simply; our system section explain the complete
implementation in detail.

* We minimize the communication with \garbler, using clever tricks, e.g.,
we don't need to send labels to \garbler for circuit garbling instead they
generate it independently using shared seed.

* publishers and subscribers only talk to the broker. The communication
between publishers and subscriber is done through \broker using end-to-end
encryption. This ensures that 

* Does the subscriber seed needs to be computation specific?

* We use ratcheting for forward security if seed is compromised.

* We assume PKI.

\paragraph{Intuition.}

\begin{figure}[h]
	\caption{Basic Protocol}
\label{fig:basicprotocol}
\begin{mdframed}[style=myframe]

%\begin{itemize}[leftmargin=*, itemsep=6pt]

\initialize
\begin{itemize}[leftmargin=*]
 
	\item Each new publisher sends \broker a policy specifying allowed
		computations on its data.
%		and generates a truly random seed $s$ and send
%		it to \garbler.

%	\item All publishers and subscribers establish an authenticated encrypted
%		channel with \broker and through \broker with \garbler.

\end{itemize}

\subscribe
\begin{itemize}[leftmargin=*]

	\item To subscribe computation $C$, subscriber sends a subscription request
		containing $C$ to \broker and requests an output mask $r$ for computation
		$C$ from \garbler.

	\item \garbler sends subscriber a pseudorandom mask $r$ for computation $C$;
		generating a new mask if this is the first subscription for computation
		$C$.

\end{itemize}

\publish
\begin{itemize}[leftmargin=*]
		
	\item To publish $k$th value, publisher generates two pseudorandom wire
		labels, $w_0$ and $w_1$, for each bit of the value. 
		
	\item For each input bit $b$, publisher sends only $w_b$ to \broker and sends
		both $w_0$ and $w_1$ to \garbler.

\end{itemize}

\compute
\begin{itemize}[leftmargin=*]

	\item Once \broker has wire labels for all publishers' inputs required for
		computation $C$, it requests \garbler to garble a circuit for $C$.  
  
	\item \garbler generates garbled circuit for $M \circ C$, composition of
		masking function $M:XOR$ and computation $C$ with a hardwired pseudorandom
		mask $r$ and sends garbled circuit to \broker.

	\item \broker evaluates the garbled circuit using wire labels sent by
		publishers, obtains masked output $o \xor r$, and sends $o \xor r$ to all
		subscribers of computation $C$.
  
	\item Subscribers use mask $r$ to unmask the output $o$.

\end{itemize}

\end{mdframed}
\end{figure}

\subsection{Basic Protocol}

\begin{figure}[h]
	\caption{Basic Protocol}
\label{fig:basicprotocol}
\begin{mdframed}[style=myframe]

%\begin{itemize}[leftmargin=*, itemsep=6pt]

\initialize
\begin{itemize}[leftmargin=*]
 
	\item Each new publisher sends \broker a policy specifying allowed
		computations on its data and generates a truly random seed $s$ and send
		it to \garbler.

	\item All publishers and subscribers establish an authenticated encrypted
		channel with \broker and through \broker with \garbler.

\end{itemize}

\subscribe
\begin{itemize}[leftmargin=*]

	\item To subscribe computation $C$, subscriber sends a subscription request
	  containing $C$ to \broker and requests an output masking seed from
	  \garbler.

	\item \garbler sends a truly random seed $s'$ to the subscriber for
		computation $C$; generating a new seed if this is the first subscription
		for computation $C$.

\end{itemize}

\publish
\begin{itemize}[leftmargin=*]
		
	\item To publish $k$th value, publisher generates two pseudorandom wire
		labels, $w_0$ and $w_1$, using seed $s$, for each bit of the value.  $w_0$
		is $i$th and $w_1$ is $(i+1)$th numbers in pseudorandom sequence generated
		using seed $s$; $2kL \leq i < 2(k+1)L$, $L$ being the bit-length of a
		value.

	\item For each input bit $b$, publisher sends only wire label $w_b$ to
		\broker.

\end{itemize}

\compute
\begin{itemize}[leftmargin=*]

	\item Once \broker has wire labels for all publishers' inputs required for
		computation $C$, it requests \garbler to garble a circuit for $C$.  
  
	\item \garbler independently generates input wire labels using seed $s$ from
		each publisher contributing input and an output mask $m$ using seed $s'$
		for each output bit.

	\item \garbler generates garbled circuit for $M \circ C(\cdot)$, composition
		of masking function $M:XOR$ and computation $C$, and sends it to \broker.

	\item \broker evaluates the garbled circuit using wire labels sent by
		publishers, obtains masked output $o \xor m$, and send $o \xor m$ to all
		subscribers of computation $C$.
  
	\item Subscribers generate the mask $m$ using the seed $s'$ and unmask the
		output $o$.

\end{itemize}

\end{mdframed}
\end{figure}

\paragraph{Forward Security.}
\unsure{Do we have to generate seed and ratchet key? Can't we use the seed as a
ratchet key?}


\begin{itemize}[leftmargin=*]

		\item Generate a truly random key $K_0$.

		\item Generate, using KDF with key $K_0$, a pseudorandom seed $s_0$ and a
			pseudorandom key for the ratchet round $1$. Seed $s_0$ is used to
			generate pseudorandom strings during ratchet round $0$.

		\item At round $r$, using KDF with key $K_r$, generate a pseudorandom seed
			$s_r$ and key for ratchet round $r+1$. Seed $s_r$ is used to generate
			pseudorandom strings during ratchet round $r$.

\end{itemize}

\paragraph{Garbled Circuit XOR Compatibility.}


* What if one publisher doesn't send wire labels. After timeout the broker can
inform the \garbler and it will use zero for such values in the circuit.

\subsection{Security Definition}

\paragraph{Ideal World.}
Our ideal functionality \F interacts with publishers, subscribers, \broker, and
\garbler as follows:

\begin{itemize}[leftmargin=*]
		\item Each publisher sends a \policy to \F and each subscriber sends a
			subscription message to \F containing subscribed computation $C$.
		
		\item All publishers whose data is required for $C$ upload data to \F. Let
			$\vec{x}$ be the vector containing all this data.

		\item \F sends $C$, \policy, and list of subscribers for $C$ to \broker.

		\item \F sends $C$ to \garbler.

		\item \garbler uploads to \F a pseudorandom mask $r$ for $C$.

		\item For each subscriber $S$ subscribed to computation $C$, \F awaits for
			\broker command allowing or denying $C(\vec{x})$; if \broker allows, \F
			sends $C(\vec{x}) \xor r$ and $r$ to $S$ and if \broker denies, \F sends
			empty message $\bot$.

\end{itemize}

\paragraph{Real World.} In real world, \F is replaced by our protocol~\ref{}.

\paragraph{Simulator.}
%In the real world, each publisher sends a \policy to
%\broker and each subscriber sends a subscription message containing computation
%$C$. For each input bit $b$, a publisher generates two wire labels, $w_0$ and
%$w_1$, sends $w_b$ to \broker, and sends both $w_0$ and $w_1$ to \garbler.
%
%Once \broker has input wire labels from all publishers whose input is required
%to compute $C$, it requests \garbler to garble a circuit for $M \circ C$, where
%$M$ is an XOR masking function. \garbler garbled circuit for $C(\cdot) \xor r$,
%with a pseudorandom mask $r$ hard wired in the circuit.
%

\improvement{We can hide $C$ using universal circuits.}
\unsure{Who forms the topics? Publishers, clients, or broker?}


\improvement{Using cut and choose for malicious security}

\unsure{What is our current model? Are publishers, subscribers malicious?}

\improvement{A publisher can always input wrong data, but there is nothing that
can be done for this? May be it could be detected if it is creating a real
problem.}

\improvement{A subscribing entity can setup it's own \garbler. First we explain
with \garbler as a separate tntity and then later explain how it can be
eliminated by transfering it's functionality to subscribers. Similary, we can
transfer some functionality to publishers. Which one of them is better?}
