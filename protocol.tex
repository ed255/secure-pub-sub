\section{Protocol}
\label{sec:protocol}

\improvement{Malicious \broker doesn't affect privacy, online correctness}


\begin{figure*}[h]
\begin{mdframed}[style=myframe]

\initialize
\begin{itemize}[leftmargin=18pt,itemsep=4pt,topsep=4pt]
 
	\item Each new publisher sends \broker a \policy specifying allowed
		computations on its data.

\end{itemize}

\subscribe
\begin{itemize}[leftmargin=18pt,itemsep=4pt,topsep=4pt]

	\item To subscribe computation $C$, subscriber sends a subscription request
		containing $C$ to \broker. If \broker allows subscriber to learn $C$'s
		output, it adds the subscriber to a list of $C$'s subscribers. 

\end{itemize}

\publish
\begin{itemize}[leftmargin=18pt,itemsep=4pt,topsep=4pt,after=]
		
	\item To publish $k$th value, publisher generates two pseudorandom wire
		labels, $w_0$ and $w_1$, for each bit of the value. 
		
	\item For each input bit $b$, publisher sends only $w_b$ to \broker and sends
		both $w_0$ and $w_1$ to \garbler.

\end{itemize}

\process
\begin{itemize}[leftmargin=18pt,itemsep=4pt,topsep=4pt]

	\item \broker waits for a specified time period $t$ to receive input wire
		labels, a single label $w_b$ for a bit $b$, from a subset of publishers
		$P_C$ whose policies allow $C$. After time period $t$, \broker sends
		\garbler identifiers of publishers in $P_C$ along with identifiers of
		publishers whose data wasn't received during time period $t$ and requests
		\garbler to garble circuit for $XOR \circ C$. $XOR$ is used to mask the
		output of the circuit.

	\item \broker sends \garbler the set of $C$'s subscribers $S_C$.
		
	\item \garbler generates a garbled circuit $GC$ for the circuit $XOR \circ C$
		using both wire labels for each input bit, $w_0$ and $w_1$ for a bit $b$,
		received from publishers in set $P_C$ hard-wiring nullifying value for
		publishers whose input labels weren't received by \broker as well as any
		publishers whose labels weren't received by \garbler. \garbler generates a
		random mask $r$ and use it to mask the output $o$ of $C$, such that
		evaluating $GC$ would result in a masked output $o+r$.
		
	\item \garbler sends $r$ to all subscribers in the set $S_C$ and $GC$ to
		\broker along with identifiers for publishers for which it hard-wired
		nullifying values.

	\item For every bit $b$ of the $C$ inputs, \garbler and \broker run a private
		set intersection \emph{cardinality} (PSI-C) protocol to determine wire
		labels consistency, i.e., if \broker input label for bit $b$, $w_b$, is one
		of the two \garbler labels for bit $b$, $w_0$ and $w_1$. If PSI-C outputs
		$1$, then the labels are consistent and if it's $0$ then the labels are
		inconsistent. \garbler will use nullifying values for inputs of all
		publishers with at least $1$ inconsistent wire label. 
		
	\item \broker evaluates the garbled circuit using wire labels sent by
		publishers in set $P_C$ ignoring labels for which \garbler hard-wired
		nullifying values, obtains masked output $o \xor r$, and sends $o \xor r$
		to all subscribers of computation $C$.
  
	\item Subscribers in the set $S_C$ use mask $r$ to unmask the output $o$.

\end{itemize}

\end{mdframed}
\caption{Basic Protocol}
\label{fig:basicprotocol}
\end{figure*}


\begin{figure}[h]
\begin{mdframed}[style=myframe]

\initialize
\begin{itemize}[leftmargin=*,itemsep=4pt,topsep=4pt]
 
	\item Each new publisher generates and sends to \garbler a truly random seed
		$s$. This seed will be used to create wire labels without interaction.

\end{itemize}

\subscribe
\begin{itemize}[leftmargin=*,itemsep=4pt,topsep=4pt]

	\item In addition to registering subscription with \broker, subscribers for a
		computation $C$ also register with \garbler. \garbler sends a truly
		random seed $s'$ for computation $C$ and send it to every subscriber who
		subscribes for $C$; generating a new seed for the first subscription for
		computation $C$.
		
\end{itemize}

\publish
\begin{itemize}[leftmargin=*,itemsep=4pt,topsep=4pt]
		
	\item To publish $k$th value, publisher generates two pseudorandom wire
		labels, $w_0$ and $w_1$, using seed $s$, for each bit of the value.  $w_0$
		is $i$th and $w_1$ is $(i+1)$th numbers in pseudorandom sequence generated
		using seed $s$; $2kL \leq i < 2(k+1)L$, $L$ being the bit-length of a
		value.

	\item For each input bit $b$, publisher sends only wire label $w_b$ to
		\broker.

\end{itemize}

\process
\begin{itemize}[leftmargin=*,itemsep=4pt,topsep=4pt]

	\item \garbler independently generates input wire labels using seed $s$ from
		each publisher contributing input and an output mask $r$ using seed $s'$
		for the output.

\end{itemize}

\vspace{8pt}

\textbf{Forward Secure Seeds}
\vspace{4pt}

Following procedure ensures that seeds $s$ and $s'$ used above are forward
	secure, i.e., compromise of seed does not affect the confidentiality of past
	data. We use Signal, a popular secure messaging protocol, key ratcheting
	protocol for forward security.

\begin{itemize}[leftmargin=*]

	\item Generate a truly random key $K_0$.

	\item Generate, using pseudorandom function (PRF) with key $K_0$, a
		pseudorandom seed $s_0$ and a pseudorandom key for the ratchet round $1$.
		Seed $s_0$ is used to generate pseudorandom strings during ratchet round
		$0$.

	\item At round $i$, using PRF with key $K_i$, generate a pseudorandom seed
		$s_i$ and key for ratchet round $i+1$. Seed $s_i$ is used to generate
		pseudorandom strings during ratchet round $i$.



\end{itemize}

\end{mdframed}
\caption{Reduced Communication Extension with Forward Security}
\label{fig:basicprotocol}
\end{figure}

\paragraph{Forward Security.}
\unsure{Do we have to generate seed and ratchet key? Can't we use the seed as a
ratchet key?}

\begin{figure}[h]
\begin{mdframed}[style=myframe]

\begin{itemize}[leftmargin=*]

		\item Generate a truly random key $K_0$.

		\item Generate, using pseudorandom function (PRF) with key $K_0$, a
			pseudorandom seed $s_0$ and a pseudorandom key for the ratchet round $1$.
			Seed $s_0$ is used to generate pseudorandom strings during ratchet round
			$0$.

		\item At round $i$, using PRF with key $K_i$, generate a pseudorandom seed
			$s_i$ and key for ratchet round $i+1$. Seed $s_i$ is used to generate
			pseudorandom strings during ratchet round $i$.

\end{itemize}

\end{mdframed}
\caption{Forward Secure Seeds for Improved Protocol}
\label{fig:basicprotocol}
\end{figure}

\noindent\textbf{Efficient Wire Labels Consistency Check.} In our basic
protocol, described in Figure~\ref{fig:basicprotocol}, we execute a new
instance of private set intersection \emph{cardinality} protocol for every
input bit of the circuit, which is expensive.  We present a more efficient wire
label consistency protocol:

For every input bit $b$ of circuit $C$, \garbler has both wire labels $w_0$ and
$w_1$, we call the set of these labels $W_\garbler$ and \broker has a wire
label $w_b$, we call the set of these labels $W_\broker$. Input consistency
check ensures that $w_b$ is either $w_0$ or $w_1$, otherwise the \broker would
be unable to evaluate the garbled circuit.

\begin{figure}[h]
\begin{mdframed}[style=myframe]

\begin{itemize}[leftmargin=*,itemsep=4pt]

	\item \broker and \garbler share an ephemeral seed $s''$ for wire label
		consistency check before every computation $C$.

	\item \broker generates a pseudorandom mask $r_b$, using seed $s''$, and
		computes $w_b \xor r_b$. We call the set of these masked input labels
		$R_\broker$. 

	\item \garbler generates the same pseudorandom mask $r_b$, using seed
		$s''$, and computes $w_0 \xor r_b$ and $w_1 \xor r_b$. We call the set of
		these masked labels $R_\garbler$.

	\item \broker and \garbler runs private set intersection (PSI) protocol with
		$R_\broker$ and $R_\garbler$ as inputs and only \broker receives the
		intersection.
		
	\item	If cardinality of $R_\broker \cap R_\garbler$ is $|R_\broker| =
		|R_\garbler / 2|$, then all wire labels are consistent. 

		\item If cardinality of $R_\broker \cap R_\garbler$ is less than
			$|R_\broker| = |R_\garbler / 2|$, then $|R_\broker| - |R_\broker \cap
			R_\garbler|$ labels are inconsistent. In this case:

			\begin{itemize}[leftmargin=*,itemsep=4pt,topsep=4pt]

					\item \broker unmasks all masked labels in $R_\broker \cap
						R_\garbler$ to learn $W_\broker \cap W_\garbler$.

					\item \broker sends all inconsistent labels $W_\broker \setminus
						(W_\broker \cap W_\garbler)$ to \garbler. 
						
					\item \garbler hard-wires in the garbled circuit $GC$ nullifying
						values for inputs of all publishers with at least $1$ inconsistent
						label.
						
			\end{itemize}
			
\end{itemize}

\end{mdframed}
\caption{Efficient Wire Label Consistency Protocol}
\label{fig:econsistency}
\end{figure}


\paragraph{Garbled Circuit XOR Compatibility.}


* What if one publisher doesn't send wire labels. After timeout the broker can
inform the \garbler and it will use zero for such values in the circuit.

\improvement{We can hide $C$ using universal circuits.}
\unsure{Who forms the topics? Publishers, clients, or broker?}


\improvement{Using cut and choose for malicious security}

\unsure{What is our current model? Are publishers, subscribers malicious?}

\improvement{A publisher can always input wrong data, but there is nothing that
can be done for this? May be it could be detected if it is creating a real
problem.}

\improvement{A subscribing entity can setup it's own \garbler. First we explain
with \garbler as a separate tntity and then later explain how it can be
eliminated by transfering it's functionality to subscribers. Similary, we can
transfer some functionality to publishers. Which one of them is better?}

\input{proof}
