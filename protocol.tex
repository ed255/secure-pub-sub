\section{Protocol}
\label{sec:protocol}

We describe our protocol. We describe system in Section~\ref{def:system}, and
we solve many issues that come into building a system.

We provide a simulator for our basic protocol, but after every extension we
describe security again.

\improvement{Malicious \broker doesn't affect privacy, online correctness}

\subsection{Basic Protocol}
\input{basic_protocol}

\subsection{Security Proof of Basic Protocol}
\input{simulator}

\subsection{Reduced Communication Extension}
\input{extended_protocol}

\subsection{Efficient Wire Labels Consistency Check} In our basic
protocol, described in Figure~\ref{fig:basicprotocol}, we execute a new
instance of private set intersection \emph{cardinality} protocol for every
input bit of the circuit, which is expensive.  We present a more efficient wire
label consistency protocol:

For every input bit $b$ of circuit $C$, \garbler has both wire labels $w_0$ and
$w_1$, we call the set of these labels $W_\garbler$ and \broker has a wire
label $w_b$, we call the set of these labels $W_\broker$. Input consistency
check ensures that $w_b$ is either $w_0$ or $w_1$, otherwise the \broker would
be unable to evaluate the garbled circuit.

\input{input_consistency_protocol}


\paragraph{Garbled Circuit XOR Compatibility.}


* What if one publisher doesn't send wire labels. After timeout the broker can
inform the \garbler and it will use zero for such values in the circuit.

\improvement{We can hide $C$ using universal circuits.}
\unsure{Who forms the topics? Publishers, clients, or broker?}


\improvement{Using cut and choose for malicious security}

\unsure{What is our current model? Are publishers, subscribers malicious?}

\improvement{A publisher can always input wrong data, but there is nothing that
can be done for this? May be it could be detected if it is creating a real
problem.}

\improvement{A subscribing entity can setup it's own \garbler. First we explain
with \garbler as a separate tntity and then later explain how it can be
eliminated by transfering it's functionality to subscribers. Similary, we can
transfer some functionality to publishers. Which one of them is better?}
