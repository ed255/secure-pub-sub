\noindent\textbf{Simulator.} \Sim receives from \F the number of publishers
$|P_C|$ whose policy allow computing $C$ on their data. \Sim creates $2l|P_C|$
random wire labels $(r_0^0, r_0^1), \ldots, (r_{2l|P_C|-1}^0
,r_{2l|P_C|-1}^1)$; $l$ being the bit-length of a publisher's input. We use
garbled circuit simulator $\Sim_{GC}$ as a blackbox; $\Sim_{GC}$ is the
simulator of the projective prv.sim secure garbling scheme with circuit $M
\circ C$ being the side information as described in~\cite{}. 

\Sim receives from \F $\F(M \circ C, \vec{x}_C)$, where $M$ is an XOR masking
function. \Sim sends $\F(M \circ C, \vec{x}_C)$ to $\Sim_{GC}$ and obtains a
fake garbled $GC_{fake}$. \Sim generates a random string $o_r$ of the same
length as output. \Sim sends $(GC_{fake}, r_0^0, \ldots, r_{2l|P_C|-1}^0, o_r)$
to \Adv. As garbled circuits distribution is independent of the input wire
labels, $GC_{fake}$ is computationally indistinguishable from the $GC$ in the
real execution. The random output $o_r$ in ideal execution is indistinguishable
from $o+r$ in the real execution.

In the ideal world, \Sim creates a fake garbled circuit $GC_{fake}$ that
doesn't use wire labels $(r_0^0, r_0^1), \ldots, (r_{2l|P_C|-1}^0
,r_{2l|P_C|-1}^1)$ for garbling. Otherwise, \Adv could use $r_0^0, \ldots,
r_{2l|P_C|-1}^0$ labels to evaluate the circuit on $0^{l|P_C|}$, which would
allow adversary to distinguish between real and ideal executions.

A malicious publisher can choose arbitrary wire labels in the real execution;
however, as long as the labels used in garbling are consistent with the labels
used for evluation, the honest subscriber output will be indistinguishable in
real and ideal executions. Our protocol ensures consistent wire labels.
